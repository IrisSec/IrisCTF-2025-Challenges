diff --git a/challenge/Makefile b/challenge/Makefile
new file mode 100644
index 0000000000..b5a02586a0
--- /dev/null
+++ b/challenge/Makefile
@@ -0,0 +1,4 @@
+all: challenge-bin
+
+challenge-bin: challenge-bin.c
+	gcc challenge-bin.c -O3 -static -nostdlib -masm=intel -o challenge-bin
diff --git a/challenge/challenge.py b/challenge/challenge.py
new file mode 100644
index 0000000000..ae3ec39173
--- /dev/null
+++ b/challenge/challenge.py
@@ -0,0 +1,81 @@
+import m5
+from m5.objects import *
+from m5.util import addToPath
+addToPath("../configs/")
+from common.Caches import *
+
+class ChallengeCache(L1Cache):
+    size = '32kB'
+    assoc = 8
+    replacement_policy = TreePLRURP()
+
+    def connectCPU(self, bus):
+        self.cpu_side = bus.mem_side_ports
+
+    def connectMem(self, bus):
+        self.mem_side = bus.cpu_side_ports
+
+system = System()
+
+system.clk_domain = SrcClockDomain()
+system.clk_domain.clock = '1GHz'
+system.clk_domain.voltage_domain = VoltageDomain()
+
+system.mem_mode = 'timing'
+system.mem_ranges = [AddrRange('32MB'), AddrRange(0xff00000000, size='1MB')]
+
+system.cpu = X86TimingSimpleCPU()
+
+system.crossbar = L2XBar()
+system.crossbar.cpu_side_ports = [system.cpu.icache_port, system.cpu.dcache_port]
+
+system.membus = SystemXBar()
+system.cache = ChallengeCache()
+system.cache.connectMem(system.membus)
+system.cache.connectCPU(system.crossbar)
+
+system.cpu.createInterruptController()
+system.cpu.interrupts[0].pio = system.membus.mem_side_ports
+system.cpu.interrupts[0].int_requestor = system.membus.cpu_side_ports
+system.cpu.interrupts[0].int_responder = system.membus.mem_side_ports
+
+system.system_port = system.membus.cpu_side_ports
+
+system.mem_ctrl = MemCtrl()
+system.mem_ctrl.dram = DDR3_1600_8x8()
+system.mem_ctrl.dram.range = system.mem_ranges[0]
+system.mem_ctrl.port = system.membus.mem_side_ports
+
+system.mem_ctrl2 = MemCtrl()
+system.mem_ctrl2.dram = DDR3_1600_8x8()
+system.mem_ctrl2.dram.range = system.mem_ranges[1]
+system.chalmem = ChallengeMemobj()
+system.mem_ctrl2.port = system.chalmem.mem_side
+system.chalmem.cpu_side = system.membus.mem_side_ports
+# system.mem_ctrl2.port = system.membus.mem_side_ports
+
+system.chal = ChallengeObj()
+system.chal.mem_side = system.crossbar.cpu_side_ports
+system.chal.data_port = system.membus.mem_side_ports
+
+print("page size",     system.mem_ctrl.dram.devices_per_rank.value
+    * system.mem_ctrl.dram.device_rowbuffer_size.value)
+
+binary = 'challenge/challenge-bin'
+
+# for gem5 V21 and beyond
+system.workload = SEWorkload.init_compatible(binary)
+
+process = Process()
+process.cmd = [binary]
+system.cpu.workload = process
+system.cpu.createThreads()
+
+root = Root(full_system = False, system = system)
+m5.instantiate()
+
+print("Beginning simulation!")
+exit_event = m5.simulate()
+
+print('Exiting @ tick {} because {}'
+      .format(m5.curTick(), exit_event.getCause()))
diff --git a/challenge/hello-world.c b/challenge/hello-world.c
new file mode 100644
index 0000000000..7e902cc496
--- /dev/null
+++ b/challenge/hello-world.c
@@ -0,0 +1,20 @@
+#include <stdint.h>
+#include <stddef.h>
+
+const char* hello = "Hello world!\n";
+
+void write(char* s, uint64_t len) {
+    asm volatile("mov rsi, %[s];mov rdx, %[len];mov rdi, 1;mov rax, 1;syscall;" : : [s]"r"(s), [len]"r"(len) : "rax", "rsi", "rdi", "rdx");
+}
+
+void _start() {
+    write(hello, 13);
+
+    // Interact with challenge IO
+    uint8_t data = 'w';
+    asm volatile("out 77, al;" : : "a"(data));
+    asm volatile("in al, 77;" : "=a"(data));
+
+    // Exit
+    asm volatile("mov rax, 60;syscall;");
+}
diff --git a/src/arch/x86/linux/syscall_tbl32.cc b/src/arch/x86/linux/syscall_tbl32.cc
index bf5d03e7b5..09d0e208e0 100644
--- a/src/arch/x86/linux/syscall_tbl32.cc
+++ b/src/arch/x86/linux/syscall_tbl32.cc
@@ -50,6 +50,7 @@ namespace X86ISA
 {
 
 SyscallDescTable<EmuLinux::SyscallABI32> EmuLinux::syscallDescs32 = {
+    /*
     {   0, "restart_syscall" },
     {   1, "exit", exitFunc },
     {   2, "fork" },
@@ -383,6 +384,7 @@ SyscallDescTable<EmuLinux::SyscallABI32> EmuLinux::syscallDescs32 = {
     { 322, "timerfd" },
     { 323, "eventfd", eventfdFunc<X86Linux32> },
     { 355, "getrandom", getrandomFunc<X86Linux32>}
+    */
 };
 
 } // namespace X86ISA
diff --git a/src/arch/x86/linux/syscall_tbl64.cc b/src/arch/x86/linux/syscall_tbl64.cc
index 1c3eebd63d..636b8bd53a 100644
--- a/src/arch/x86/linux/syscall_tbl64.cc
+++ b/src/arch/x86/linux/syscall_tbl64.cc
@@ -50,8 +50,10 @@ namespace X86ISA
 {
 
 SyscallDescTable<EmuLinux::SyscallABI64> EmuLinux::syscallDescs64 = {
-    {   0, "read", readFunc<X86Linux64> },
+    // {   0, "read", readFunc<X86Linux64> },
     {   1, "write", writeFunc<X86Linux64> },
+    {  60, "exit", exitFunc },
+    /*
     {   2, "open", openFunc<X86Linux64> },
     {   3, "close", closeFunc },
     {   4, "stat", stat64Func<X86Linux64> },
@@ -110,7 +112,6 @@ SyscallDescTable<EmuLinux::SyscallABI64> EmuLinux::syscallDescs64 = {
     {  57, "fork" },
     {  58, "vfork" },
     {  59, "execve", execveFunc<X86Linux64> },
-    {  60, "exit", exitFunc },
     {  61, "wait4", wait4Func<X86Linux64> },
     {  62, "kill" },
     {  63, "uname", unameFunc },
@@ -416,6 +417,7 @@ SyscallDescTable<EmuLinux::SyscallABI64> EmuLinux::syscallDescs64 = {
     { 448, "process_mrelease" },
     { 449, "futex_waitv" },
     { 450, "set_mempolicy_home_node" }
+    */
 };
 
 } // namespace X86ISA
diff --git a/src/challenge/ChallengeMemobj.py b/src/challenge/ChallengeMemobj.py
new file mode 100644
index 0000000000..1bfed3cdb5
--- /dev/null
+++ b/src/challenge/ChallengeMemobj.py
@@ -0,0 +1,37 @@
+# Copyright (c) 2017 Jason Lowe-Power
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+from m5.params import *
+from m5.SimObject import SimObject
+
+
+class ChallengeMemobj(SimObject):
+    type = "ChallengeMemobj"
+    cxx_header = "challenge/challenge_memobj.hh"
+    cxx_class = "gem5::ChallengeMemobj"
+
+    cpu_side = ResponsePort("CPU side port, receives requests")
+    mem_side = RequestPort("Memory side port, sends requests")
diff --git a/src/challenge/ChallengeObj.py b/src/challenge/ChallengeObj.py
new file mode 100644
index 0000000000..0d4b1cf9f1
--- /dev/null
+++ b/src/challenge/ChallengeObj.py
@@ -0,0 +1,39 @@
+# Copyright (c) 2017 Jason Lowe-Power
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+from m5.params import *
+from m5.proxy import *
+from m5.SimObject import SimObject
+
+class ChallengeObj(SimObject):
+    type = "ChallengeObj"
+    cxx_header = "challenge/challenge_obj.hh"
+    cxx_class = "gem5::ChallengeObj"
+
+    data_port = ResponsePort("CPU side port, receives requests")
+    mem_side = RequestPort("Memory side port, sends requests")
+
+    system = Param.System(Parent.any, "System we belong to")
\ No newline at end of file
diff --git a/src/challenge/SConscript b/src/challenge/SConscript
new file mode 100644
index 0000000000..f1ec138552
--- /dev/null
+++ b/src/challenge/SConscript
@@ -0,0 +1,38 @@
+# -*- coding: utf-8 -*-
+# Copyright (c) 2017 Jason Lowe-Power
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Jason Lowe-Power
+
+Import('*')
+
+SimObject('ChallengeObj.py', sim_objects=["ChallengeObj"])
+SimObject('ChallengeMemobj.py', sim_objects=["ChallengeMemobj"])
+Source('challenge_obj.cc')
+Source('challenge_memobj.cc')
+
+DebugFlag('ChallengeObj', "wass6p")
+DebugFlag('ChallengeMemobj', "wass7p")
diff --git a/src/challenge/challenge_memobj.cc b/src/challenge/challenge_memobj.cc
new file mode 100644
index 0000000000..77ffefbd2b
--- /dev/null
+++ b/src/challenge/challenge_memobj.cc
@@ -0,0 +1,229 @@
+/*
+ * Copyright (c) 2017 Jason Lowe-Power
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "challenge/challenge_memobj.hh"
+
+#include "base/trace.hh"
+#include "debug/ChallengeMemobj.hh"
+
+namespace gem5
+{
+
+ChallengeMemobj::ChallengeMemobj(const ChallengeMemobjParams &params) :
+    SimObject(params),
+    cpuPort(params.name + ".cpu_side", this),
+    memPort(params.name + ".mem_side", this),
+    blocked(false)
+{
+}
+
+Port &
+ChallengeMemobj::getPort(const std::string &if_name, PortID idx)
+{
+    panic_if(idx != InvalidPortID, "This object doesn't support vector ports");
+
+    // This is the name from the Python SimObject declaration (ChallengeMemobj.py)
+    if (if_name == "mem_side") {
+        return memPort;
+    } else if (if_name == "cpu_side") {
+        return cpuPort;
+    } else {
+        // pass it along to our super class
+        return SimObject::getPort(if_name, idx);
+    }
+}
+
+void
+ChallengeMemobj::CPUSidePort::sendPacket(PacketPtr pkt)
+{
+    // Note: This flow control is very simple since the memobj is blocking.
+
+    panic_if(blockedPacket != nullptr, "Should never try to send if blocked!");
+
+    // If we can't send the packet across the port, store it for later.
+    if (!sendTimingResp(pkt)) {
+        blockedPacket = pkt;
+    }
+}
+
+AddrRangeList
+ChallengeMemobj::CPUSidePort::getAddrRanges() const
+{
+    return owner->getAddrRanges();
+}
+
+void
+ChallengeMemobj::CPUSidePort::trySendRetry()
+{
+    if (needRetry && blockedPacket == nullptr) {
+        // Only send a retry if the port is now completely free
+        needRetry = false;
+        DPRINTF(ChallengeMemobj, "Sending retry req for %d\n", id);
+        sendRetryReq();
+    }
+}
+
+void
+ChallengeMemobj::CPUSidePort::recvFunctional(PacketPtr pkt)
+{
+    // Just forward to the memobj.
+    return owner->handleFunctional(pkt);
+}
+
+bool
+ChallengeMemobj::CPUSidePort::recvTimingReq(PacketPtr pkt)
+{
+    // Just forward to the memobj.
+    if (!owner->handleRequest(pkt)) {
+        needRetry = true;
+        return false;
+    } else {
+        return true;
+    }
+}
+
+void
+ChallengeMemobj::CPUSidePort::recvRespRetry()
+{
+    // We should have a blocked packet if this function is called.
+    assert(blockedPacket != nullptr);
+
+    // Grab the blocked packet.
+    PacketPtr pkt = blockedPacket;
+    blockedPacket = nullptr;
+
+    // Try to resend it. It's possible that it fails again.
+    sendPacket(pkt);
+}
+
+void
+ChallengeMemobj::MemSidePort::sendPacket(PacketPtr pkt)
+{
+    // Note: This flow control is very simple since the memobj is blocking.
+
+    panic_if(blockedPacket != nullptr, "Should never try to send if blocked!");
+
+    // If we can't send the packet across the port, store it for later.
+    if (!sendTimingReq(pkt)) {
+        blockedPacket = pkt;
+    }
+}
+
+bool
+ChallengeMemobj::MemSidePort::recvTimingResp(PacketPtr pkt)
+{
+    // Just forward to the memobj.
+    return owner->handleResponse(pkt);
+}
+
+void
+ChallengeMemobj::MemSidePort::recvReqRetry()
+{
+    // We should have a blocked packet if this function is called.
+    assert(blockedPacket != nullptr);
+
+    // Grab the blocked packet.
+    PacketPtr pkt = blockedPacket;
+    blockedPacket = nullptr;
+
+    // Try to resend it. It's possible that it fails again.
+    sendPacket(pkt);
+}
+
+void
+ChallengeMemobj::MemSidePort::recvRangeChange()
+{
+    owner->sendRangeChange();
+}
+
+bool
+ChallengeMemobj::handleRequest(PacketPtr pkt)
+{
+    panic_if(!pkt->isSecure(), "NO");
+
+    if (blocked) {
+        // There is currently an outstanding request. Stall.
+        DPRINTF(ChallengeMemobj, "Got blocked for addr %#x\n", pkt->getAddr());
+
+        return false;
+    }
+
+    DPRINTF(ChallengeMemobj, "Got request for addr %#x - needs resp is %u\n", pkt->getAddr(), pkt->needsResponse());
+
+    // This memobj is now blocked waiting for the response to this packet.
+    if(pkt->needsResponse()) blocked = true;
+
+    // Simply forward to the memory port
+    memPort.sendPacket(pkt);
+
+    return true;
+}
+
+bool
+ChallengeMemobj::handleResponse(PacketPtr pkt)
+{
+    assert(blocked);
+    DPRINTF(ChallengeMemobj, "Got response for addr %#x\n", pkt->getAddr());
+
+    // The packet is now done. We're about to put it in the port, no need for
+    // this object to continue to stall.
+    // We need to free the resource before sending the packet in case the CPU
+    // tries to send another request immediately (e.g., in the same callchain).
+    blocked = false;
+
+    // Simply forward to the memory port
+    cpuPort.sendPacket(pkt);
+
+    // For each of the cpu ports, if it needs to send a retry, it should do it
+    // now since this memory object may be unblocked now.
+    cpuPort.trySendRetry();
+
+    return true;
+}
+
+void
+ChallengeMemobj::handleFunctional(PacketPtr pkt)
+{
+    // Just pass this on to the memory side to handle for now.
+    memPort.sendFunctional(pkt);
+}
+
+AddrRangeList
+ChallengeMemobj::getAddrRanges() const
+{
+    DPRINTF(ChallengeMemobj, "Sending new ranges\n");
+    return memPort.getAddrRanges();
+}
+
+void
+ChallengeMemobj::sendRangeChange()
+{
+    cpuPort.sendRangeChange();
+}
+
+} // namespace gem5
diff --git a/src/challenge/challenge_memobj.hh b/src/challenge/challenge_memobj.hh
new file mode 100644
index 0000000000..3593262755
--- /dev/null
+++ b/src/challenge/challenge_memobj.hh
@@ -0,0 +1,260 @@
+/*
+ * Copyright (c) 2017 Jason Lowe-Power
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CHALLENGE_MEMOBJ_HH__
+#define __CHALLENGE_MEMOBJ_HH__
+
+#include "mem/port.hh"
+#include "params/ChallengeMemobj.hh"
+#include "sim/sim_object.hh"
+
+namespace gem5
+{
+
+/**
+ * A very simple memory object. Current implementation doesn't even cache
+ * anything it just forwards requests and responses.
+ * This memobj is fully blocking (not non-blocking). Only a single request can
+ * be outstanding at a time.
+ */
+class ChallengeMemobj : public SimObject
+{
+  private:
+
+    /**
+     * Port on the CPU-side that receives requests.
+     * Mostly just forwards requests to the owner.
+     * Part of a vector of ports. One for each CPU port (e.g., data, inst)
+     */
+    class CPUSidePort : public ResponsePort
+    {
+      private:
+        /// The object that owns this object (ChallengeMemobj)
+        ChallengeMemobj *owner;
+
+        /// True if the port needs to send a retry req.
+        bool needRetry;
+
+        /// If we tried to send a packet and it was blocked, store it here
+        PacketPtr blockedPacket;
+
+      public:
+        /**
+         * Constructor. Just calls the superclass constructor.
+         */
+        CPUSidePort(const std::string& name, ChallengeMemobj *owner) :
+            ResponsePort(name), owner(owner), needRetry(false),
+            blockedPacket(nullptr)
+        { }
+
+        /**
+         * Send a packet across this port. This is called by the owner and
+         * all of the flow control is hanled in this function.
+         *
+         * @param packet to send.
+         */
+        void sendPacket(PacketPtr pkt);
+
+        /**
+         * Get a list of the non-overlapping address ranges the owner is
+         * responsible for. All response ports must override this function
+         * and return a populated list with at least one item.
+         *
+         * @return a list of ranges responded to
+         */
+        AddrRangeList getAddrRanges() const override;
+
+        /**
+         * Send a retry to the peer port only if it is needed. This is called
+         * from the ChallengeMemobj whenever it is unblocked.
+         */
+        void trySendRetry();
+
+      protected:
+        /**
+         * Receive an atomic request packet from the request port.
+         * No need to implement in this simple memobj.
+         */
+        Tick recvAtomic(PacketPtr pkt) override
+        { panic("recvAtomic unimpl."); }
+
+        /**
+         * Receive a functional request packet from the request port.
+         * Performs a "debug" access updating/reading the data in place.
+         *
+         * @param packet the requestor sent.
+         */
+        void recvFunctional(PacketPtr pkt) override;
+
+        /**
+         * Receive a timing request from the request port.
+         *
+         * @param the packet that the requestor sent
+         * @return whether this object can consume the packet. If false, we
+         *         will call sendRetry() when we can try to receive this
+         *         request again.
+         */
+        bool recvTimingReq(PacketPtr pkt) override;
+
+        /**
+         * Called by the request port if sendTimingResp was called on this
+         * response port (causing recvTimingResp to be called on the request
+         * port) and was unsuccesful.
+         */
+        void recvRespRetry() override;
+
+        bool
+        tryTiming(PacketPtr pkt) override
+        {
+          return true;
+        }
+    };
+
+    /**
+     * Port on the memory-side that receives responses.
+     * Mostly just forwards requests to the owner
+     */
+    class MemSidePort : public RequestPort
+    {
+      private:
+        /// The object that owns this object (ChallengeMemobj)
+        ChallengeMemobj *owner;
+
+        /// If we tried to send a packet and it was blocked, store it here
+        PacketPtr blockedPacket;
+
+      public:
+        /**
+         * Constructor. Just calls the superclass constructor.
+         */
+        MemSidePort(const std::string& name, ChallengeMemobj *owner) :
+            RequestPort(name), owner(owner), blockedPacket(nullptr)
+        { }
+
+        /**
+         * Send a packet across this port. This is called by the owner and
+         * all of the flow control is hanled in this function.
+         *
+         * @param packet to send.
+         */
+        void sendPacket(PacketPtr pkt);
+
+      protected:
+        /**
+         * Receive a timing response from the response port.
+         */
+        bool recvTimingResp(PacketPtr pkt) override;
+
+        /**
+         * Called by the response port if sendTimingReq was called on this
+         * request port (causing recvTimingReq to be called on the responder
+         * port) and was unsuccesful.
+         */
+        void recvReqRetry() override;
+
+        /**
+         * Called to receive an address range change from the peer responder
+         * port. The default implementation ignores the change and does
+         * nothing. Override this function in a derived class if the owner
+         * needs to be aware of the address ranges, e.g. in an
+         * interconnect component like a bus.
+         */
+        void recvRangeChange() override;
+    };
+
+    /**
+     * Handle the request from the CPU side
+     *
+     * @param requesting packet
+     * @return true if we can handle the request this cycle, false if the
+     *         requestor needs to retry later
+     */
+    bool handleRequest(PacketPtr pkt);
+
+    /**
+     * Handle the respone from the memory side
+     *
+     * @param responding packet
+     * @return true if we can handle the response this cycle, false if the
+     *         responder needs to retry later
+     */
+    bool handleResponse(PacketPtr pkt);
+
+    /**
+     * Handle a packet functionally. Update the data on a write and get the
+     * data on a read.
+     *
+     * @param packet to functionally handle
+     */
+    void handleFunctional(PacketPtr pkt);
+
+    /**
+     * Return the address ranges this memobj is responsible for. Just use the
+     * same as the next upper level of the hierarchy.
+     *
+     * @return the address ranges this memobj is responsible for
+     */
+    AddrRangeList getAddrRanges() const;
+
+    /**
+     * Tell the CPU side to ask for our memory ranges.
+     */
+    void sendRangeChange();
+
+    /// Instantiation of the CPU-side ports
+    CPUSidePort cpuPort;
+
+    /// Instantiation of the memory-side port
+    MemSidePort memPort;
+
+    /// True if this is currently blocked waiting for a response.
+    bool blocked;
+
+  public:
+
+    /** constructor
+     */
+    ChallengeMemobj(const ChallengeMemobjParams &params);
+
+    /**
+     * Get a port with a given name and index. This is used at
+     * binding time and returns a reference to a protocol-agnostic
+     * port.
+     *
+     * @param if_name Port name
+     * @param idx Index in the case of a VectorPort
+     *
+     * @return A reference to the given port
+     */
+    Port &getPort(const std::string &if_name,
+                  PortID idx=InvalidPortID) override;
+};
+
+} // namespace gem5
+
+#endif // __LEARNING_GEM5_PART2_SIMPLE_MEMOBJ_HH__
diff --git a/src/challenge/challenge_obj.cc b/src/challenge/challenge_obj.cc
new file mode 100644
index 0000000000..0049dfd417
--- /dev/null
+++ b/src/challenge/challenge_obj.cc
@@ -0,0 +1,296 @@
+/*
+ * Copyright (c) 2017 Jason Lowe-Power
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "challenge_obj.hh"
+
+#include "base/trace.hh"
+#include "mem/packet_access.hh"
+#include "sim/system.hh"
+#include "debug/ChallengeObj.hh"
+
+namespace gem5
+{
+
+ChallengeObj::ChallengeObj(const ChallengeObjParams &params) :
+    SimObject(params),
+    dataPort(params.name + ".data_port", this),
+    memPort(params.name + ".mem_side", this),
+    counter(0ull),
+    checkCounter(0ull),
+    checkStartTime(0ull),
+    requestorID(params.system->getRequestorId(this)),
+    sys(params.system),
+    initPacket(nullptr),
+    blocked(false),
+    checking(false),
+    correct(false)
+{
+}
+
+Port &
+ChallengeObj::getPort(const std::string &if_name, PortID idx)
+{
+    panic_if(idx != InvalidPortID, "This object doesn't support vector ports");
+
+    // This is the name from the Python SimObject declaration (ChallengeObj.py)
+    if (if_name == "mem_side") {
+        return memPort;
+    } else if (if_name == "data_port") {
+        return dataPort;
+    } else {
+        // pass it along to our super class
+        return SimObject::getPort(if_name, idx);
+    }
+}
+
+void
+ChallengeObj::CPUSidePort::sendPacket(PacketPtr pkt)
+{
+    // Note: This flow control is very simple since the memobj is blocking.
+
+    panic_if(blockedPacket != nullptr, "Should never try to send if blocked!");
+
+    // If we can't send the packet across the port, store it for later.
+    if (!sendTimingResp(pkt)) {
+        blockedPacket = pkt;
+    }
+}
+
+AddrRangeList
+ChallengeObj::CPUSidePort::getAddrRanges() const
+{
+    return owner->getAddrRanges();
+}
+
+void
+ChallengeObj::CPUSidePort::trySendRetry()
+{
+    if (needRetry && blockedPacket == nullptr) {
+        // Only send a retry if the port is now completely free
+        needRetry = false;
+        DPRINTF(ChallengeObj, "Sending retry req for %d\n", id);
+        sendRetryReq();
+    }
+}
+
+void
+ChallengeObj::CPUSidePort::recvFunctional(PacketPtr pkt)
+{
+    panic("Whar");
+}
+
+bool
+ChallengeObj::CPUSidePort::recvTimingReq(PacketPtr pkt)
+{
+    // Just forward to the memobj.
+    if (!owner->handleRequest(pkt)) {
+        needRetry = true;
+        return false;
+    } else {
+        return true;
+    }
+}
+
+void
+ChallengeObj::CPUSidePort::recvRespRetry()
+{
+    // We should have a blocked packet if this function is called.
+    assert(blockedPacket != nullptr);
+
+    // Grab the blocked packet.
+    PacketPtr pkt = blockedPacket;
+    blockedPacket = nullptr;
+
+    // Try to resend it. It's possible that it fails again.
+    sendPacket(pkt);
+}
+
+void
+ChallengeObj::MemSidePort::sendPacket(PacketPtr pkt)
+{
+    sendTimingReq(pkt);
+}
+
+bool
+ChallengeObj::MemSidePort::recvTimingResp(PacketPtr pkt)
+{
+    // Just forward to the memobj.
+    return owner->handleResponse(pkt);
+}
+
+void
+ChallengeObj::MemSidePort::recvReqRetry()
+{
+    panic("Whar");
+}
+
+void
+ChallengeObj::MemSidePort::recvRangeChange()
+{
+    owner->sendRangeChange();
+}
+
+const char* flag = "irisctf{this_is_a_testing_flag_}";
+const uint64_t flag_len = 32;
+
+void ChallengeObj::checkNextByte(PacketPtr pkt)
+{
+    if(checkCounter > flag_len) {
+        if(checkCounter == 0x2000ull) { // done
+            auto newPkt = initPacket;
+            initPacket = nullptr;
+            newPkt->setLE<uint8_t>(correct);
+            newPkt->makeResponse();
+            schedule(new EventFunctionWrapper(
+                [this, newPkt] {
+                    dataPort.sendPacket(newPkt);
+                }, name() + ".respond", true
+            ), checkStartTime + 10000000ull);
+            blocked = false;
+            checking = false;
+        } else {
+            RequestPtr req = std::make_shared<Request>(0xff00000000ull + checkCounter - 0x1000ull, 1, Request::CLEAN | Request::INVALIDATE | Request::SECURE | Request::DST_POC, requestorID);
+            PacketPtr newPkt = new Packet(req, MemCmd::CleanInvalidReq);
+            memPort.sendPacket(newPkt);
+            checkCounter += sys->cacheLineSize();
+        }
+    } else {
+        correct = pkt->getLE<uint8_t>() == flag[checkCounter];
+        if(checkCounter == flag_len - 1 || !correct) {
+            checkCounter = 0x1000ull;
+
+            RequestPtr req = std::make_shared<Request>(0xff00000000ull + checkCounter - 0x1000ull, 1, Request::CLEAN | Request::INVALIDATE | Request::SECURE | Request::DST_POC, requestorID);
+            PacketPtr newPkt = new Packet(req, MemCmd::CleanInvalidReq);
+            memPort.sendPacket(newPkt);
+            checkCounter += sys->cacheLineSize();
+        } else {
+            checkCounter += 1;
+
+            // New access
+            auto checkCounterA = counter - flag_len + checkCounter;
+            checkCounterA %= 0x1000ull;
+
+            RequestPtr req = std::make_shared<Request>(0xff00000000ull + checkCounterA, 1, Request::SECURE, requestorID);
+            PacketPtr newPkt = new Packet(req, MemCmd::ReadReq);
+            newPkt->allocate();
+            memPort.sendPacket(newPkt);
+        }
+    }
+    delete pkt;
+}
+
+bool
+ChallengeObj::handleRequest(PacketPtr pkt)
+{
+    
+    if (blocked) {
+        // There is currently an outstanding request. Stall.
+        return false;
+    }
+
+    DPRINTF(ChallengeObj, "Got request for addr %#x\n", pkt->getAddr());
+
+    // This memobj is now blocked waiting for the response to this packet.
+    blocked = true;
+    initPacket = pkt;
+
+    DPRINTF(ChallengeObj, "isRead = %d - size = %u\n", pkt->isRead(), pkt->getSize());
+    panic_if(pkt->getSize() != 1, "Size must be 1 byte.\n");
+    uint8_t data = pkt->getLE<uint8_t>();
+    DPRINTF(ChallengeObj, "data = %u\n", data);
+
+    if(!pkt->isRead()) {
+        // Store input
+        RequestPtr req = std::make_shared<Request>(0xff00000000ull + counter, 1, Request::SECURE, requestorID);
+        counter += 1;
+        if(counter >= 0x1000ull) counter = 0;
+        PacketPtr newPkt = new Packet(req, MemCmd::WriteReq);
+        newPkt->allocate();
+        newPkt->setLE<uint8_t>(data);
+        memPort.sendPacket(newPkt);
+    } else {
+        // Trigger flag check
+        checkStartTime = curTick();
+        checking = true;
+        checkCounter = 0ull;
+        auto checkCounterA = counter - flag_len + checkCounter;
+        checkCounterA %= 0x1000ull;
+
+        RequestPtr req = std::make_shared<Request>(0xff00000000ull + checkCounterA, 1, Request::SECURE, requestorID);
+        PacketPtr newPkt = new Packet(req, MemCmd::ReadReq);
+        newPkt->allocate();
+        memPort.sendPacket(newPkt);
+    }
+
+    return true;
+}
+
+bool
+ChallengeObj::handleResponse(PacketPtr pkt)
+{
+    assert(blocked);
+    DPRINTF(ChallengeObj, "Got response for addr %#x\n", pkt->getAddr());
+
+
+    if(checking) {
+        checkNextByte(pkt);
+    } else {
+        blocked = false;
+        auto newPkt = initPacket;
+        initPacket = nullptr;
+        newPkt->makeResponse();
+        dataPort.sendPacket(newPkt);
+        delete pkt;
+    }
+    return true;
+}
+
+void
+ChallengeObj::handleFunctional(PacketPtr pkt)
+{   
+    panic("Whar");
+}
+
+AddrRangeList
+ChallengeObj::getAddrRanges() const
+{
+    DPRINTF(ChallengeObj, "Sending new ranges\n");
+
+    AddrRangeList ranges;
+    ranges.push_back(RangeEx(0x800000000000004d, 0x8000000000000052));
+
+    return ranges;
+}
+
+void
+ChallengeObj::sendRangeChange()
+{
+    dataPort.sendRangeChange();
+}
+
+} // namespace gem5
diff --git a/src/challenge/challenge_obj.hh b/src/challenge/challenge_obj.hh
new file mode 100644
index 0000000000..c280406b14
--- /dev/null
+++ b/src/challenge/challenge_obj.hh
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2017 Jason Lowe-Power
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CHALLENGE_OBJ_HH__
+#define __CHALLENGE_OBJ_HH__
+
+#include "mem/port.hh"
+#include "params/ChallengeObj.hh"
+#include "sim/sim_object.hh"
+
+namespace gem5
+{
+
+class ChallengeObj: public SimObject
+{
+  private:
+    /**
+     * Port on the CPU-side that receives requests.
+     * Mostly just forwards requests to the owner.
+     * Part of a vector of ports. One for each CPU port (e.g., data, inst)
+     */
+    class CPUSidePort : public ResponsePort
+    {
+      private:
+        /// The object that owns this object (SimpleMemobj)
+        ChallengeObj *owner;
+
+        /// True if the port needs to send a retry req.
+        bool needRetry;
+        PacketPtr blockedPacket;
+      public:
+        /**
+         * Constructor. Just calls the superclass constructor.
+         */
+        CPUSidePort(const std::string& name, ChallengeObj *owner) :
+            ResponsePort(name), owner(owner), needRetry(false)
+        { }
+
+        /**
+         * Send a packet across this port. This is called by the owner and
+         * all of the flow control is hanled in this function.
+         *
+         * @param packet to send.
+         */
+        void sendPacket(PacketPtr pkt);
+
+        /**
+         * Get a list of the non-overlapping address ranges the owner is
+         * responsible for. All response ports must override this function
+         * and return a populated list with at least one item.
+         *
+         * @return a list of ranges responded to
+         */
+        AddrRangeList getAddrRanges() const override;
+
+        /**
+         * Send a retry to the peer port only if it is needed. This is called
+         * from the SimpleMemobj whenever it is unblocked.
+         */
+        void trySendRetry();
+
+      protected:
+        /**
+         * Receive an atomic request packet from the request port.
+         * No need to implement in this simple memobj.
+         */
+        Tick recvAtomic(PacketPtr pkt) override
+        { panic("recvAtomic unimpl."); }
+
+        /**
+         * Receive a functional request packet from the request port.
+         * Performs a "debug" access updating/reading the data in place.
+         *
+         * @param packet the requestor sent.
+         */
+        void recvFunctional(PacketPtr pkt) override;
+
+        /**
+         * Receive a timing request from the request port.
+         *
+         * @param the packet that the requestor sent
+         * @return whether this object can consume the packet. If false, we
+         *         will call sendRetry() when we can try to receive this
+         *         request again.
+         */
+        bool recvTimingReq(PacketPtr pkt) override;
+
+        /**
+         * Called by the request port if sendTimingResp was called on this
+         * response port (causing recvTimingResp to be called on the request
+         * port) and was unsuccesful.
+         */
+        void recvRespRetry() override;
+    };
+
+    /**
+     * Port on the memory-side that receives responses.
+     * Mostly just forwards requests to the owner
+     */
+    class MemSidePort : public RequestPort
+    {
+      private:
+        /// The object that owns this object (SimpleMemobj)
+        ChallengeObj *owner;
+
+      public:
+        /**
+         * Constructor. Just calls the superclass constructor.
+         */
+        MemSidePort(const std::string& name, ChallengeObj *owner) :
+            RequestPort(name), owner(owner)
+        { }
+
+        /**
+         * Send a packet across this port. This is called by the owner and
+         * all of the flow control is hanled in this function.
+         *
+         * @param packet to send.
+         */
+        void sendPacket(PacketPtr pkt);
+
+      protected:
+        /**
+         * Receive a timing response from the response port.
+         */
+        bool recvTimingResp(PacketPtr pkt) override;
+
+        /**
+         * Called by the response port if sendTimingReq was called on this
+         * request port (causing recvTimingReq to be called on the responder
+         * port) and was unsuccesful.
+         */
+        void recvReqRetry() override;
+
+        /**
+         * Called to receive an address range change from the peer responder
+         * port. The default implementation ignores the change and does
+         * nothing. Override this function in a derived class if the owner
+         * needs to be aware of the address ranges, e.g. in an
+         * interconnect component like a bus.
+         */
+        void recvRangeChange() override;
+    };
+
+    void checkNextByte(PacketPtr pkt);
+
+    /**
+     * Handle the request from the CPU side
+     *
+     * @param requesting packet
+     * @return true if we can handle the request this cycle, false if the
+     *         requestor needs to retry later
+     */
+    bool handleRequest(PacketPtr pkt);
+
+    /**
+     * Handle the respone from the memory side
+     *
+     * @param responding packet
+     * @return true if we can handle the response this cycle, false if the
+     *         responder needs to retry later
+     */
+    bool handleResponse(PacketPtr pkt);
+
+    /**
+     * Handle a packet functionally. Update the data on a write and get the
+     * data on a read.
+     *
+     * @param packet to functionally handle
+     */
+    void handleFunctional(PacketPtr pkt);
+
+    /**
+     * Return the address ranges this memobj is responsible for. Just use the
+     * same as the next upper level of the hierarchy.
+     *
+     * @return the address ranges this memobj is responsible for
+     */
+    AddrRangeList getAddrRanges() const;
+
+    /**
+     * Tell the CPU side to ask for our memory ranges.
+     */
+    void sendRangeChange();
+
+    /// Instantiation of the CPU-side ports
+    CPUSidePort dataPort;
+
+    /// Instantiation of the memory-side port
+    MemSidePort memPort;
+
+    uint64_t counter, checkCounter;
+    Tick checkStartTime;
+    RequestorID requestorID;
+    System* sys;
+    PacketPtr initPacket;
+
+    /// True if this is currently blocked waiting for a response.
+    bool blocked;
+    bool checking;
+    bool correct;
+
+  public:
+
+    /** constructor
+     */
+    ChallengeObj(const ChallengeObjParams &params);
+
+    /**
+     * Get a port with a given name and index. This is used at
+     * binding time and returns a reference to a protocol-agnostic
+     * port.
+     *
+     * @param if_name Port name
+     * @param idx Index in the case of a VectorPort
+     *
+     * @return A reference to the given port
+     */
+    Port &getPort(const std::string &if_name,
+                  PortID idx=InvalidPortID) override;
+};
+
+} // namespace gem5
+
+#endif
diff --git a/src/cpu/translation.hh b/src/cpu/translation.hh
index 2156a50e8f..39e3ef9af3 100644
--- a/src/cpu/translation.hh
+++ b/src/cpu/translation.hh
@@ -254,7 +254,8 @@ class DataTranslation : public BaseMMU::Translation
            BaseMMU::Mode mode)
     {
         assert(state);
-        assert(mode == state->mode);
+        // https://github.com/gem5/gem5/pull/1080/commits/f4d63b88e7be644d78b1db01349e5f8ca4851929
+        assert(mode == state->mode || req->isCacheClean());
         if (state->finish(fault, index)) {
             if (state->getFault() == NoFault) {
                 // Don't access the request if faulted (due to squash)
